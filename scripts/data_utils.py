# -*- coding: utf-8 -*-
"""
Created on Thu Apr 12 14:34:47 2018

@author: Gemma
"""

import tiffcapture as tc 
import numpy as np
import cv2
from matplotlib import pyplot as plt

# =============================================================================
# VIDEO UTILS
# =============================================================================
def form_tiff_to_listarray(filename):
    print("Convert tiff file")
    tiff = tc.opentiff(filename)
    listarray=[]
    for img in tiff:
        listarray.append(img)
    return listarray

def form_avi_to_listarray(filename):
    print("Convert avi file")
    cap = cv2.VideoCapture(filename)
#    fps = cap.get(cv2.CAP_PROP_FPS)
    listarray=[]
    ret=True
    while(ret):
        ret, frame = cap.read()
        if ret:
            listarray.append(frame)
    return listarray

def create_video(filename,data,fps):
    print("Create video")
    size=data[0].shape
    writer = cv2.VideoWriter(filename,cv2.VideoWriter_fourcc(*'XVID'),fps,size,False)
    for i in range(len(data)):
        frame=data[i]+1
        writer.write(np.uint8(frame))   
    return

# =============================================================================
# PLOT FUNCTION
# =============================================================================
def print_frame_in_listarray(array,num_of_frame):
    for i in range(num_of_frame):
        plt.figure()
        plt.imshow(array[i])
        plt.colorbar()
    return

def print_subplot_frame_from_two_listarray(array1,title1,array2,title2,num_of_frame):
    for i in range(num_of_frame):
        plt.figure()
        plt.subplot(121)
        plt.imshow(array1[i])
        plt.title(title1)
        plt.clim(-1,1)
        plt.colorbar()
        plt.subplot(122)
        plt.title(title2)
        plt.imshow(array2[i])
        plt.clim(-1,1)
        plt.colorbar()
    return

# =============================================================================
# ISCAS PAPER FUNCTIONS
# =============================================================================
# LinLog conversion as in the iscas 2012 paper
# The mapping from linear intensity reading (0-255) to log brightness measure is not useful for 
# discrete sample values near zero because log is a very expansive function for positive
# values near zero, resulting in a high number of events caused by sensor noise. 
# To handle these small values, we use a “linlog” mapping which maps linearly up to some value 
# (typically 20) and then maps logarithmically for the rest of the sample values, up to 255."
# =============================================================================

def conversionFunctionISCAS2012(x,thr):
    y=np.zeros(x.shape)
    indLin=x<thr
    indLog=np.invert(indLin)
    y[indLin]=x[indLin]
    y[indLog]=np.log(x[indLog]-thr+1)+thr
    return y

# =============================================================================
# Linear Timestamp as in the iscas 2012 paper
# "The timestamp assigned to each synthetic VSBE event is chosen optionally either to be the frame time 
# or a time interpolated between the last frame and this one. If the time is set to the frame time, 
# all events generated by that frame are synchronous, which causes many of the existing event-based
# processing algorithms which depend on precise event timing to fail. Therefore the optional time 
# interpolation assigns a timestamp to each separate event within a pixel by linearly interpolating 
# between the last and current frame timestamps with the total number of events in that pixel. 
# 5 events from one pixel, for instance, will have timestamps separated by 1/5 of the frame interval. 
# These timestamps serve to desynchronize otherwise simultaneous events but do not increase timing
# precision, since they are synthetic and the event times are not related to actual visual input."
# =============================================================================

def linearTimestampISCAS2012(events,indexOn,indexOff,timestamp_array):
    numbOn=indexOn[0].shape[0]
    numbOff=indexOff[0].shape[0]
    eventsOn=np.array([indexOn[0],indexOn[1],1*np.ones(numbOn)])
    eventsOff=np.array([indexOff[0],indexOff[1],0*np.ones(numbOff)])
    tmp_events=np.concatenate((eventsOn,eventsOff), axis=1)
    ind = np.lexsort((tmp_events[1],tmp_events[0]))
    [(tmp_events[0][i],tmp_events[1][i],tmp_events[2][i]) for i in ind]
    tmp_events_time=np.append(tmp_events,[timestamp_array],axis=0)
    events.append(np.transpose(tmp_events_time))
    return events